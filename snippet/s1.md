### Watch Ch  设计
from: config-center 
惊艳点： valueChs 的作用，用于广播信号。
```
func (d *dataContainer) WatchCh() <-chan interface{} {
	ch := make(chan interface{}, 1)
	d.mu.Lock()
	defer d.mu.Unlock()
	d.valueChs = append(d.valueChs, ch)
	return ch
}
```


### notification channel 的设计

- 这个 5 个 channel 的处理有什么问题？
- 是不是可以有更好的解决办法？将 channel 包一层？queue 处理？
- 怎么测试是否存在这种情况呢？

```
	TimingWheel struct {
		interval      time.Duration
		ticker        timex.Ticker
		slots         []*list.List
		timers        *SafeMap
		tickedPos     int
		numSlots      int
		execute       Execute

///  
		setChannel    chan timingEntry
		moveChannel   chan baseEntry
		removeChannel chan interface{}
		drainChannel  chan func(key, value interface{})
		stopChannel   chan lang.PlaceholderType
/// 
	}
```

```
func (tw *TimingWheel) run() {
	for {
		select {
		case <-tw.ticker.Chan():
			tw.onTick()
		case task := <-tw.setChannel:
			tw.setTask(&task)
		case key := <-tw.removeChannel:
			tw.removeTask(key)
		case task := <-tw.moveChannel:
			tw.moveTask(task)
		case fn := <-tw.drainChannel:
			tw.drainAll(fn)
		case <-tw.stopChannel:
			tw.ticker.Stop()
			return
		}
	}
}
```

更好的做法是：
```
// PubSub is a collection of topics.
type PubSub struct {
	cmdChan  chan cmd
	capacity int
}

type cmd struct {
	op     operation
	topics []string
	ch     chan interface{}
	msg    interface{}
}
```